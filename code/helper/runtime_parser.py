# ---------- Runtime Parser (human-in-the-loop; NON-LLM) ----------
# Implements the “Parser working principle” in Fig. 3:
#   (a) Start from code sketch                -> generated by LLM Task Manager
#   (b) Human gives natural edit instruction  -> this function parses it
#   (c) Parser extracts structure + applies   -> edits the sketch deterministically
#   (d) (Optional) send refined body to LLM   -> handled elsewhere; not here
#
# Supported command pattern (robust to mild wording variation):
#   "Add an instance MUX_1 of module mux_4 within GPE_4"
#   "add instance instX of module foo within bar"
#   "insert instance pe0 of module pe within array_core"
#
# Effect:
#   - Finds file for parent module (e.g., GPE_4) using module_index.json
#   - Parses the *module mux_4* declaration to extract its port list (if sketch exists)
#   - Inserts a SystemVerilog instantiation into the parent module body, before 'endmodule'
#     using either discovered ports or a single placeholder: ".port(port)".
#
# Artifacts:
#   - Writes modified file in-place (or returns a preview diff if dry_run=True)
#   - Logs a small JSON change record for auditability

import re, json, difflib, datetime as dt
from pathlib import Path
from typing import Optional, Dict, List, Tuple

# ---------- folders (relative to this file) ----------
CUR_DIR   = Path(__file__).resolve().parent
DIR_IN    = CUR_DIR / "inputs"
DIR_HELP  = CUR_DIR / "helper"
DIR_OUT   = CUR_DIR / "generated"
DIR_LOG   = CUR_DIR / "logs"

# ------------- utilities -------------
def _load_module_index(module_index_path: Path) -> Dict:
    return json.loads(Path(module_index_path).read_text())

def _find_module_file(mod_index: Dict, name: str) -> Path:
    info = mod_index["modules"].get(name)
    if not info:
        raise FileNotFoundError(f"Module '{name}' not found in module_index.json")
    return Path(info["filename"])

def _read_file(p: Path) -> List[str]:
    return Path(p).read_text().splitlines(keepends=True)

def _write_file(p: Path, text: str) -> None:
    Path(p).write_text(text)

def _now_iso() -> str:
    return dt.datetime.utcnow().isoformat() + "Z"

# ------------- SV helpers -------------
_module_decl_re = re.compile(
    r'(?is)^\s*module\s+(?P<name>[A-Za-z_]\w*)\s*'
    r'(?:#\s*\((?P<params>.*?)\))?\s*'
    r'\((?P<ports>.*?)\)\s*;'
)

def _parse_sv_header(text: str) -> Tuple[str, List[str]]:
    """
    Return (module_name, port_order_list) if header found, else ("", []).
    We only need names; directions/types are ignored.
    """
    m = _module_decl_re.search(text)
    if not m:
        return "", []
    mod = m.group("name")
    ports_raw = m.group("ports")
    # split ports by commas, strip trailing comments/dir/types
    # heuristic: last token in each comma-separated chunk is the port name
    ports: List[str] = []
    for chunk in ports_raw.split(","):
        token = re.sub(r'//.*', '', chunk)                # strip // comments
        token = re.sub(r'/\*.*?\*/', '', token, flags=re.S)
        token = token.strip()
        if not token:
            continue
        # remove keywords/types/packed dims
        token = re.sub(r'\b(input|output|inout|logic|wire|reg|signed|unsigned)\b', '', token)
        token = re.sub(r'\[[^\]]*\]', '', token)          # widths
        name = token.split()[-1] if token.split() else ""
        name = re.sub(r'[^A-Za-z0-9_$]', '', name)
        if name:
            ports.append(name)
    return mod, ports

def _make_instantiation(callee_mod: str, inst_name: str, callee_ports: List[str]) -> str:
    if not callee_ports:
        # minimal placeholder as in the paper
        return f"{callee_mod} {inst_name} (\n  .port(port)\n);\n"
    # map 1:1 to same-named signals; user will fix later in TB or parent ports
    port_lines = [f"  .{p}({p})" for p in callee_ports]
    return f"{callee_mod} {inst_name} (\n" + ",\n".join(port_lines) + "\n);\n"

def _insert_before_endmodule(parent_src_lines: List[str], block: str) -> List[str]:
    """
    Insert the block before the last 'endmodule'.
    If a '/* body block */' placeholder exists, prefer inserting just above it.
    """
    text = "".join(parent_src_lines)
    body_placeholder = re.search(r'/\*\s*body\s+block\s*\*/', text, flags=re.IGNORECASE)
    if body_placeholder:
        # insert at placeholder start
        idx = body_placeholder.start()
        # compute line index
        prefix = text[:idx]
        line_no = prefix.count("\n")
        new_lines = parent_src_lines[:line_no] + [block] + parent_src_lines[line_no:]
        return new_lines

    # otherwise, before the last endmodule
    last_em = None
    for i, line in enumerate(parent_src_lines):
        if re.search(r'^\s*endmodule\b', line):
            last_em = i
    if last_em is None:
        # no endmodule; append
        return parent_src_lines + [block]
    return parent_src_lines[:last_em] + [block] + parent_src_lines[last_em:]

# ------------- command parsing -------------
_cmd_re = re.compile(
    r'^\s*(add|insert)\s+an?\s+instance\s+(?P<inst>[A-Za-z_]\w*)\s+of\s+module\s+(?P<mod>[A-Za-z_]\w*)\s+within\s+(?P<parent>[A-Za-z_]\w*)\s*\.?\s*$',
    flags=re.IGNORECASE
)

def _parse_command(cmd: str) -> Dict[str, str]:
    m = _cmd_re.match(cmd.strip())
    if not m:
        raise ValueError("Unsupported command. Expected: 'Add an instance <INST> of module <MOD> within <PARENT>'")
    return {
        "action": "add_instance",
        "instance": m.group("inst"),
        "module": m.group("mod"),
        "parent": m.group("parent"),
    }

# ------------- main entry point -------------
def runtime_parser_apply(
    command: str,
    module_index_path: Path,
    *,
    dry_run: bool = True,
    change_log_path: Optional[Path] = None,
) -> Dict[str, str]:
    """
    Apply a human edit command to sketches deterministically (no LLM).
    Returns a dict with keys:
      {status, parent_file, callee_file?, preview?}
    If dry_run=True, writes no files and returns a unified diff in 'preview'.
    """
    mod_index = _load_module_index(module_index_path)
    parsed = _parse_command(command)

    inst  = parsed["instance"]
    callee = parsed["module"]
    parent = parsed["parent"]

    parent_file = _find_module_file(mod_index, parent)
    callee_file = _find_module_file(mod_index, callee) if callee in mod_index["modules"] else None

    parent_src = _read_file(parent_file)

    # obtain callee ports (if callee sketch exists)
    callee_ports: List[str] = []
    if callee_file and callee_file.exists():
        callee_src = callee_file.read_text()
        _, callee_ports = _parse_sv_header(callee_src)

    inst_block = _make_instantiation(callee, inst, callee_ports)
    new_parent_src = _insert_before_endmodule(parent_src, inst_block)

    old_text = "".join(parent_src)
    new_text = "".join(new_parent_src)

    if dry_run:
        diff = "".join(difflib.unified_diff(
            old_text.splitlines(keepends=True),
            new_text.splitlines(keepends=True),
            fromfile=str(parent_file),
            tofile=str(parent_file) + " (modified)",
        ))
        return {
            "status": "PREVIEW",
            "parent_file": str(parent_file),
            "callee_file": str(callee_file) if callee_file else "",
            "preview": diff,
        }

    # write modification
    _write_file(parent_file, new_text)

    # append change log
    if change_log_path is None:
        change_log_path = (DIR_OUT / "runtime_changes.json") if "DIR_OUT" in globals() else Path("runtime_changes.json")
    try:
        log = []
        if change_log_path.exists():
            log = json.loads(change_log_path.read_text())
        log.append({
            "ts": _now_iso(),
            "command": command,
            "parent": parent,
            "instance": inst,
            "module": callee,
            "parent_file": str(parent_file),
            "callee_file": str(callee_file) if callee_file else "",
        })
        change_log_path.write_text(json.dumps(log, indent=2))
    except Exception:
        pass

    return {
        "status": "APPLIED",
        "parent_file": str(parent_file),
        "callee_file": str(callee_file) if callee_file else "",
        "preview": "",
    }

# ------------- convenience wrappers -------------
def runtime_parser_preview(command: str, module_index_path: Path) -> str:
    """Return a unified diff preview for the command without writing files."""
    res = runtime_parser_apply(command, module_index_path, dry_run=True)
    return res.get("preview", "")

def runtime_parser_commit(command: str, module_index_path: Path) -> Dict[str, str]:
    """Apply the command and write the modified file."""
    return runtime_parser_apply(command, module_index_path, dry_run=False)
